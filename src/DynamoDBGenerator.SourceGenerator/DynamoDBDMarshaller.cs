using System.Collections.Immutable;
using System.Diagnostics;
using DynamoDBGenerator.SourceGenerator.Extensions;
using DynamoDBGenerator.SourceGenerator.Types;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static DynamoDBGenerator.SourceGenerator.Constants.DynamoDBGenerator.Attribute.DynamoDbMarshallerOptionsArgument;

namespace DynamoDBGenerator.SourceGenerator;

[Generator]
// ReSharper disable once InconsistentNaming
public class DynamoDBDMarshaller : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var updateClassDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                Constants.DynamoDBGenerator.DynamoDBMarshallerFullname,
                (n, _) => n is ClassDeclarationSyntax or RecordDeclarationSyntax or StructDeclarationSyntax,
                (c, _) => c.TargetNode
            );

        var compilationAndClasses = context.CompilationProvider.Combine(updateClassDeclarations.Collect());
        context.RegisterSourceOutput(compilationAndClasses, Execute);
    }

    // https://github.com/dotnet/runtime/blob/4ea93a6be4ea1b084158cf2aed7cac2414f10a2d/src/libraries/System.Text.Json/gen/JsonSourceGenerator.Roslyn4.0.cs
    private static void Execute(SourceProductionContext context,
        (Compilation Left, ImmutableArray<SyntaxNode> Right) tuple)
    {
        var (compilation, classDeclarationSyntax) = tuple;

        if (classDeclarationSyntax.IsDefaultOrEmpty)
            return;

        foreach (var typeSymbol in compilation.GetTypeSymbols(classDeclarationSyntax))
        {
            context.AddSource(
                $"{typeSymbol.ToDisplayString()}.g",
                string.Join(Constants.NewLine, CreateFileContent(typeSymbol, compilation))
            );
        }
    }

    private static IEnumerable<string> CreateFileContent(INamedTypeSymbol type, Compilation compilation)
    {
        var timestamp = Stopwatch.GetTimestamp();
        yield return $@"// <auto-generated | TimeStamp: {DateTime.Now:yyyy-MM-dd HH:mm:ss}>
#nullable enable
using System;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using {Constants.AWSSDK_DynamoDBv2.Namespace.ModelFullName};
using {Constants.DynamoDBGenerator.Namespace.Root};
using {Constants.DynamoDBGenerator.Namespace.AttributesFullName};
using {Constants.DynamoDBGenerator.Namespace.ExceptionsFullName};
using {Constants.DynamoDBGenerator.Namespace.InternalFullName};";

        var typeType = type switch
        {
            { IsRecord: true, TypeKind: TypeKind.Class, IsSealed: true } => "sealed partial record",
            { IsRecord: true, TypeKind: TypeKind.Class, IsSealed: false } => "partial record",
            { IsRecord: false, TypeKind: TypeKind.Class, IsSealed: true } => "sealed partial class",
            { IsRecord: false, TypeKind: TypeKind.Class, IsSealed: false } => "partial class",
            { IsRecord: true, TypeKind: TypeKind.Struct or TypeKind.Structure, IsReadOnly: true } => "readonly partial record struct",
            { IsRecord: false, TypeKind: TypeKind.Struct or TypeKind.Structure, IsReadOnly: true } => "readonly partial struct",
            { IsRecord: false, TypeKind: TypeKind.Struct or TypeKind.Structure, IsReadOnly: false } => "partial struct",
            _ => throw new NotImplementedException("Could not determine whether the type is a struct, class or record.")
        };

        if (type.DeclaredAccessibility is not Accessibility.Public)
            throw new NotImplementedException(
                $"Generate accessibility of '{type.DeclaredAccessibility}' on '{type.ToDisplayParts()}' only '{type.DeclaredAccessibility == Accessibility.Public}' is supported."
            );

        var (options, args) = CreateArguments(type, compilation);
        var classContent = $"public {(type.IsStatic ? "static " : null)}{typeType} {type.Name}"
              .CreateScope(MarshallerFactory.CreateRepository(args, options));

        var content = type.ContainingNamespace.IsGlobalNamespace
            ? classContent
            : $"namespace {type.ContainingNamespace.ToDisplayString()}".CreateScope(classContent);

        foreach (var s in content)
            yield return s;

        var duration = TimeSpan.FromTicks(Stopwatch.GetTimestamp() - timestamp);

        yield return $"// <auto-generated | Duration {duration.ToString()}>";
    }

    private static (MarshallerOptions, IEnumerable<DynamoDBMarshallerArguments>) CreateArguments(ISymbol type,
        Compilation compilation)
    {
        var attributes = type.GetAttributes();
        var marshallerOptionNamedArguments = attributes.Where(x => x.AttributeClass is
        {
            Name: Constants.DynamoDBGenerator.Attribute.DynamoDbMarshallerOptions,
            ContainingNamespace.Name: Constants.DynamoDBGenerator.Namespace.Attributes,
            ContainingAssembly.Name: Constants.DynamoDBGenerator.AssemblyName
        })
            .SelectMany(x => x.NamedArguments)
            .ToArray();

        var enumStrategy = marshallerOptionNamedArguments
            .Where(x => x.Key is EnumConversionStrategy)
            .Where(x => x.Value.Kind is TypedConstantKind.Enum)
            .Select(x => x.Value.Value)
            .OfType<int?>()
            .FirstOrDefault(x => x is not null) ?? ConversionStrategy.Integer;

        var converter = marshallerOptionNamedArguments
                            .Where(x => x.Key is Converters)
                            .Select(x => x.Value.Value)
                            .OfType<INamedTypeSymbol>()
                            .FirstOrDefault(x => x is not null) ??
                        compilation.GetTypeByMetadataName(Constants.DynamoDBGenerator.DynamoDBConverterFullName);

        if (converter is null)
            throw new ArgumentException("Could not find converter implementation");

        return (MarshallerOptions.Create(converter, enumStrategy), Arguments(attributes, type));

        static IEnumerable<DynamoDBMarshallerArguments> Arguments(ImmutableArray<AttributeData> attributes, ISymbol type)
        {
            foreach (var attributeData in attributes)
            {
                if (attributeData.AttributeClass is
                    {
                        ContainingNamespace.Name: Constants.DynamoDBGenerator.Namespace.Attributes,
                        Name: Constants.DynamoDBGenerator.Attribute.DynamoDBMarshaller,
                        ContainingAssembly.Name: Constants.DynamoDBGenerator.AssemblyName
                    } is false)
                    continue;

                var entityType = attributeData.NamedArguments
                  .Where(x => x.Key is Constants.DynamoDBGenerator.Attribute.DynamoDBMarshallerArgument.EntityType)
                  .Cast<KeyValuePair<string, TypedConstant>?>()
                  .FirstOrDefault() is { } entityType1
                  ? entityType1.Value is { Value: INamedTypeSymbol et }
                    ? et
                    : throw new ArgumentException(
                                $"Could not determine type conversion from argument '{entityType1.Key}'.")
                : type;

                if (entityType is not INamedTypeSymbol entityTypeSymbol)
                    throw new ArgumentException("Could not determine type conversion from attribute constructor.");

                var propertyName = attributeData.NamedArguments.FirstOrDefault(x =>
                    x.Key is Constants.DynamoDBGenerator.Attribute.DynamoDBMarshallerArgument.AccessName).Value;
                yield return new DynamoDBMarshallerArguments(
                    entityTypeSymbol,
                    attributeData.NamedArguments
                        .Where(x => x.Key is Constants.DynamoDBGenerator.Attribute.DynamoDBMarshallerArgument
                            .ArgumentType)
                        .Cast<KeyValuePair<string, TypedConstant>?>()
                        .FirstOrDefault() is { } argumentType
                        ? argumentType.Value is
                        { Value: INamedTypeSymbol namedTypeSymbol }
                            ? namedTypeSymbol
                            : throw new ArgumentException(
                                $"Could not determine type conversion from argument '{argumentType.Key}'.")
                        : null,
                    propertyName.Value?.ToString()
                );
            }
        }
    }
}
